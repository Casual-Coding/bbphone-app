define(function(require) {
// Generated by CoffeeScript 1.8.0
var BBCodeParser, BBCodeTag, InvalidTokenException, Node, SimpleTag, Token, boldTag, codeTag, imageTag, italicTag, linkTag, listItemTag, listTag, modTag, monotypeTag, parser, quoteTag, spoilerTag, strikeTage, triggerTag, underlineTag,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

BBCodeParser = (function() {
  function BBCodeParser() {
    this.argsPattern = XRegExp("([^,\"]+)|(\"[^\"]+\")");
    this.regExSkeleton = "(.*?)((\\[\\s*(%tags%)\\s*([= ]((\\s*((\"[^\"]+?\")|" + "([^,\\]\"]+?))\\s*,)*(\\s*((\"[^\"]+?\")|([^,\"\\]]+?))\\s*)))?\\])|" + "(\\[\\/\\s*((%tags%))\\s*\\]))";
    this.tags = {};
  }

  BBCodeParser.getAllTags = function() {
    return "string, b, u, s, i, mod, spoiler, code, img, quote, url, list, table, m, tex";
  };

  BBCodeParser.prototype.registerTag = function(tag) {
    return this.tags[tag.tag] = tag;
  };

  BBCodeParser.prototype.generatePattern = function() {
    var name, tag, tags;
    tags = ((function() {
      var _ref, _results;
      _ref = this.tags;
      _results = [];
      for (name in _ref) {
        tag = _ref[name];
        _results.push(XRegExp.escape(name));
      }
      return _results;
    }).call(this)).join("|");
    return XRegExp(this.regExSkeleton.replace(/%tags%/gi, tags, "gi"), "imsg");
  };

  BBCodeParser.prototype.parse = function(input) {
    var args, argsMatch, beginning, current, e, end, endBBCode, lastMatched, match, pattern, pos, recovery, root, startBBCode, subPos, t, token, tokens;
    lastMatched = 0;
    tokens = [];
    startBBCode = input.indexOf("[");
    endBBCode = input.lastIndexOf("]");
    beginning = "";
    end = "";
    try {
      beginning = this.stringToHTML(input.substr(0, startBBCode));
      end = this.stringToHTML(input.substr(endBBCode + 1));
      input = input.substr(startBBCode, endBBCode + 1);
    } catch (_error) {

    }
    root = new Node();
    current = root;
    pattern = this.generatePattern();
    pos = 0;
    while (match = XRegExp.exec(input, pattern, pos, "sticky")) {
      pos = match.index + match[0].length;
      if (match[1].length > 0) {
        t = new Token;
        t.initialize(Token.TYPE_STRING, this.stringToHTML(match[1]));
        tokens.push(t);
      }
      if (match[2].indexOf("[/") > -1) {
        t = new Token;
        t.initializeWithTag(Token.TYPE_CLOSE, match[16].toLowerCase(), match[2]);
        tokens.push(t);
      } else {
        args = [];
        if (match[6] && match[6].length > 0) {
          subPos = 0;
          while (argsMatch = XRegExp.exec(match[6], this.argsPattern, subPos, "sticky")) {
            subPos = argsMatch.index + argsMatch[0].length;
            args.push(argsMatch[0].replace(/\"/, ""));
          }
        }
        t = new Token;
        t.initializeWithArguments(Token.TYPE_OPEN, match[4].toLowerCase(), match[2], args);
        tokens.push(t);
      }
      lastMatched = pos;
    }
    if (input.substr(lastMatched).length > 0) {
      t = new Token(Token.TYPE_STRING, this.stringToHTML(input.substr(lastMatched)));
      tokens.push(t);
    }
    while (tokens.length > 0) {
      if (tokens[0].type === Token.TYPE_STRING) {
        try {
          current = this.addString(current, tokens[0].text);
        } catch (_error) {
          e = _error;
          switch (current.tag.invalidStringRecovery) {
            case BBCodeTag.RECOVERY_ADD:
              t = new Token;
              t.initialize(Token.TYPE_OPEN, current.tag.invalidRecoveryAddTag);
              tokens.unshift(t);
              break;
            default:
              throw new Error("Unknown error");
          }
          continue;
        }
      }
      if (tokens[0].type === Token.TYPE_OPEN) {
        try {
          token = tokens[0];
          current = this.addStart(current, token.tag, token.args, token.text);
        } catch (_error) {
          e = _error;
          if (this.isAllowedAnywhere(current, tokens[0].tag) && current.tag.invalidStartRecovery !== BBCodeTag.RECOVERY_ADD) {
            recovery = BBCodeTag.RECOVERY_STRING;
          } else {
            recovery = current.tag.invalidStartRecovery;
          }
          if (this.isAllowedAnywhere(current, tokens[0].tag) && current.tag.invalidStartRecovery !== BBCodeTag.RECOVERY_ADD) {
            recovery = BBCodeTag.RECOVERY_STRING;
          }
          switch (recovery) {
            case BBCodeTag.RECOVERY_ADD:
              t = new Token;
              t.initialize(Token.TYPE_OPEN, current.tag.invalidRecoveryAddTag);
              tokens.unshift(t);
              break;
            case BBCodeTag.RECOVERY_CLOSE:
              t = new Token;
              t.initialize(Token.TYPE_CLOSE, current.tag.tag);
              tokens.unshift(t);
              break;
            case BBCodeTag.RECOVERY_STRING:
              tokens[0].type = Token.TYPE_STRING;
              break;
            default:
              throw new Error("Unkown Error");
          }
          continue;
        }
      }
      if (tokens[0].type === Token.TYPE_CLOSE) {
        try {
          token = tokens[0];
          current = this.addEnd(current, token.tag, token.text);
        } catch (_error) {
          e = _error;
          if (!this.isOpen(current, tokens[0].tag)) {
            recovery = BBCodeTag.RECOVERY_STRING;
          } else {
            recovery = current.tag.invalidEndRecovery;
          }
          switch (recovery) {
            case BBCodeTag.RECOVERY_REOPEN:
              t = new Token;
              t.initialize(Token.TYPE_CLOSE, current.tag.tag);
              tokens.unshift(t);
              t = new Token;
              t.initialize(Token.TYPE_OPEN, current.tag.tag);
              tokens.splice(2, 0, t);
              break;
            case BBCodeTag.RECOVERY_CLOSE:
              t = new Token;
              t.initialize(Token.TYPE_CLOSE, current.tag.tag);
              tokens.unshift(t);
              break;
            case BBCodeTag.RECOVERY_STRING:
              tokens[0].type = Token.TYPE_STRING;
              break;
            default:
              throw new Error("Unkown Error");
          }
          continue;
        }
      }
      tokens.shift();
    }
    return beginning + root.toString() + end;
  };

  BBCodeParser.prototype.addString = function(current, string) {
    var newNode;
    if (!current.isRoot() && current.tag.allowedTags.indexOf("string") === -1) {
      throw new InvalidTokenException;
    }
    newNode = new Node;
    newNode.initialize(string);
    newNode.parent = current;
    current.children.push(newNode);
    return current;
  };

  BBCodeParser.prototype.addStart = function(current, tagString, args, raw) {
    var newNode, tag;
    if (!current.isRoot() && current.tag.allowedTags.indexOf(tagString) === -1) {
      throw new InvalidTokenException;
    }
    tag = this.tags[tagString];
    newNode = new Node;
    newNode.initializeWithRaw(tag, args, raw);
    newNode.parent = current;
    current.children.push(newNode);
    return newNode;
  };

  BBCodeParser.prototype.addEnd = function(current, tagString, raw) {
    if (current.isRoot() || tagString !== current.tag.tag) {
      throw new InvalidTokenException;
    }
    return current.close(raw);
  };

  BBCodeParser.prototype.isOpen = function(current, tagString) {
    if (current.isRoot()) {
      return false;
    }
    if (current.tag.tag === tagString) {
      return true;
    } else {
      return this.isOpen(current.parent, tagString);
    }
  };

  BBCodeParser.prototype.isAllowedAnywhere = function(current, tagString) {
    if (current.isRoot()) {
      return false;
    }
    if (current.tag.allowedTags.indexOf(tagString) !== -1) {
      return true;
    } else {
      return this.isAllowedAnywhere(current.parent, tagString);
    }
  };

  BBCodeParser.prototype.stringToHTML = function(input) {
    input = input.replace(/</g, "&lt;");
    input = input.replace(/>/g, "&gt;");
    return input.replace(/\n/g, "<br>\n");
  };

  return BBCodeParser;

})();

BBCodeTag = (function() {
  BBCodeTag.RECOVERY_NONE = 0;

  BBCodeTag.RECOVERY_STRING = 1;

  BBCodeTag.RECOVERY_CLOSE = 2;

  BBCodeTag.RECOVERY_REOPEN = 3;

  BBCodeTag.RECOVERY_ADD = 4;

  function BBCodeTag() {
    this.invalidEndRecovery = BBCodeTag.RECOVERY_STRING;
    this.invalidStringRecovery = BBCodeTag.RECOVERY_NONE;
    this.invalidStartRecovery = BBCodeTag.RECOVERY_STRING;
    this.invalidRecoveryAddTag = "";
    this.tag = null;
    this.description = "";
    this.allowedTags = [];
    this.text = "";
  }

  BBCodeTag.prototype.initialize = function(tag, name) {
    this.tag = tag;
    this.name = name;
    return this.allowTags(BBCodeParser.getAllTags());
  };

  BBCodeTag.prototype.initializeWithAllowedTags = function(tag, name, allowed) {
    this.tag = tag;
    this.name = name;
    return this.allowTags(allowed);
  };

  BBCodeTag.prototype.setInvalidStartRecovery = function(recovery) {
    this.invalidStartRecovery = recovery;
    return this;
  };

  BBCodeTag.prototype.setInvalidEndRecovery = function(recovery) {
    this.invalidEndRecovery = recovery;
    return this;
  };

  BBCodeTag.prototype.setInvalidStringRecovery = function(recovery) {
    this.invalidStringRecovery = recovery;
    return this;
  };

  BBCodeTag.prototype.setInvalidRecoveryTag = function(tag) {
    this.invalidRecoveryAddTag = tag;
    return this;
  };

  BBCodeTag.prototype.html = function(content, args) {
    return console.error("You have to implement an html method");
  };

  BBCodeTag.prototype.allowTags = function(tags) {
    var tag;
    this.allowedTags = (function() {
      var _i, _len, _ref, _results;
      _ref = tags.split(",");
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tag = _ref[_i];
        _results.push(tag.replace(" ", ""));
      }
      return _results;
    })();
    return this;
  };

  return BBCodeTag;

})();

Token = (function() {
  Token.TYPE_STRING = 0;

  Token.TYPE_OPEN = 1;

  Token.TYPE_CLOSE = 2;

  function Token() {
    this.type = null;
    this.text = null;
    this.tag = null;
    this.args = null;
  }

  Token.prototype.initialize = function(type, text) {
    this.type = type;
    if (this.type === Token.TYPE_STRING) {
      return this.text = text;
    } else {
      this.tag = text;
      if (this.type === Token.TYPE_OPEN) {
        this.text = "[" + this.tag + "]";
      }
      if (this.type === Token.TYPE_CLOSE) {
        return this.text = "[/" + this.tag + "]";
      }
    }
  };

  Token.prototype.initializeWithTag = function(type, tag, text) {
    this.type = type;
    this.tag = tag;
    return this.text = text;
  };

  Token.prototype.initializeWithArguments = function(type, tag, text, args) {
    this.type = type;
    this.tag = tag;
    this.text = text;
    return this.args = args;
  };

  return Token;

})();

Node = (function() {
  function Node() {
    this.children = [];
    this.parent = null;
    this.tag = null;
    this.text = null;
    this.args = null;
    this.rawStart = null;
    this.rawEnd = null;
    this.invalid = false;
  }

  Node.prototype.initialize = function(text) {
    return this.text = text;
  };

  Node.prototype.initializeWithRaw = function(type, args, raw) {
    this.tag = type;
    this.args = args;
    return this.rawStart = raw;
  };

  Node.prototype.close = function(raw) {
    if (raw) {
      this.rawEnd = raw;
    } else {
      this.rawEnd = "[/" + this.tag.tag + "]";
    }
    return this.parent;
  };

  Node.prototype.hasTag = function() {
    return this.tag !== null;
  };

  Node.prototype.isRoot = function() {
    return this.tag === null && this.text === null;
  };

  Node.prototype.isString = function() {
    return this.text !== null;
  };

  Node.prototype.isInvalid = function() {
    return this.invalid;
  };

  Node.prototype.toString = function() {
    var n, res;
    if (this.isString()) {
      return this.text;
    }
    res = ((function() {
      var _i, _len, _ref, _results;
      _ref = this.children;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        _results.push(n.toString());
      }
      return _results;
    }).call(this)).join("");
    if (this.isRoot()) {
      return res;
    }
    if (res === "") {
      return res;
    }
    if (this.isInvalid()) {
      return this.rawStart + res + this.rawEnd;
    }
    return this.tag.html(res, this.args);
  };

  return Node;

})();

InvalidTokenException = (function(_super) {
  __extends(InvalidTokenException, _super);

  function InvalidTokenException() {
    return InvalidTokenException.__super__.constructor.apply(this, arguments);
  }

  return InvalidTokenException;

})(Error);

SimpleTag = (function(_super) {
  __extends(SimpleTag, _super);

  function SimpleTag(tag, name, allowed) {
    SimpleTag.__super__.constructor.apply(this, arguments);
    if (allowed) {
      this.initializeWithAllowedTags(tag, name, allowed);
    } else {
      this.initialize(tag, name);
    }
  }

  SimpleTag.prototype.initialize = function(tag, name) {
    SimpleTag.__super__.initialize.apply(this, arguments);
    this.setInvalidStartRecovery(BBCodeTag.RECOVERY_CLOSE);
    return this.setInvalidEndRecovery(BBCodeTag.RECOVERY_REOPEN);
  };

  SimpleTag.prototype.initializeWithAllowedTags = function(tag, name, allowed) {
    SimpleTag.__super__.initializeWithAllowedTags.apply(this, arguments);
    this.setInvalidStartRecovery(BBCodeTag.RECOVERY_CLOSE);
    return this.setInvalidEndRecovery(BBCodeTag.RECOVERY_REOPEN);
  };

  SimpleTag.prototype.html = function() {
    return "";
  };

  return SimpleTag;

})(BBCodeTag);

parser = new BBCodeParser;

boldTag = new SimpleTag("b", "bold");

boldTag.html = function(content) {
  return "<strong>" + content + "</strong>";
};

parser.registerTag(boldTag);

monotypeTag = new SimpleTag("m", "monotype", "string");

monotypeTag.html = function(content) {
  return "<pre class=\"inline\">" + content + "</pre>";
};

parser.registerTag(monotypeTag);

underlineTag = new SimpleTag("u", "underline");

underlineTag.html = function(content) {
  return "<u>" + content + "</u>";
};

parser.registerTag(underlineTag);

strikeTage = new SimpleTag("s", "strike");

strikeTage.html = function(content) {
  return "<del>" + content + "</del>";
};

parser.registerTag(strikeTage);

italicTag = new SimpleTag("i", "italic");

italicTag.html = function(content) {
  return "<em>" + content + "</em>";
};

parser.registerTag(italicTag);

codeTag = new SimpleTag("code", "code");

codeTag.html = function(content) {
  return "<div class=\"code\">" + content + "</div>";
};

parser.registerTag(codeTag);

spoilerTag = new SimpleTag("spoiler", "spoiler");

spoilerTag.html = function(content) {
  return "<div class=\"spoiler\"><div>" + content + "</div></div>";
};

parser.registerTag(spoilerTag);

modTag = new SimpleTag("mod", "mod");

modTag.html = function(content) {
  return "<span class=\"mod\">" + content + "</span>";
};

parser.registerTag(modTag);

triggerTag = new SimpleTag("trigger", "trigger");

triggerTag.html = function(content) {
  return "<span class=\"trigger\">" + content + "</span>";
};

parser.registerTag(triggerTag);

listTag = new BBCodeTag();

listTag.initializeWithAllowedTags("list", "list", "*");

listTag.html = function(content) {
  return "<ul>" + content + "</ul>";
};

listTag.setInvalidStartRecovery(BBCodeTag.RECOVERY_ADD);

listTag.setInvalidEndRecovery(BBCodeTag.RECOVERY_CLOSE);

listTag.setInvalidStringRecovery(BBCodeTag.RECOVERY_ADD);

listTag.setInvalidRecoveryTag("*");

parser.registerTag(listTag);

listItemTag = new BBCodeTag();

listItemTag.initialize("*", "listitem");

listItemTag.html = function(content) {
  if (content.replace("<br>", "").trim().length === 0) {
    return "";
  } else {
    return "<li>" + content + "</li>";
  }
};

listItemTag.setInvalidStartRecovery(BBCodeTag.RECOVERY_CLOSE);

listItemTag.setInvalidEndRecovery(BBCodeTag.RECOVERY_CLOSE);

parser.registerTag(listItemTag);

linkTag = new SimpleTag("url", "link", "string, b, u, s, i, mod, img, url, list, table, m");

linkTag.html = function(content, args) {
  var url;
  url = content;
  if (args.length > 0) {
    url = args[0];
  }
  return "<a href=\"" + url + "\">" + content + "</a>";
};

parser.registerTag(linkTag);

imageTag = new SimpleTag("img", "image", "string");

imageTag.html = function(content, args) {
  return "<div class=\"image not-loaded\" data-image=\"" + content + "\"></div>";
};

parser.registerTag(imageTag);

quoteTag = new SimpleTag("quote", "quote");

quoteTag.html = function(content, args) {
  if (args.length === 3) {
    return "<blockquote data-thread-id=\"" + args[0] + "\" data-post-id=\"" + args[1] + "\" data-author=\"" + args[2] + "\">" + content + "</blockquote>";
  } else {
    return "<blockquote>" + content + "</blockquote>";
  }
};

parser.registerTag(quoteTag);


  return parser;
});